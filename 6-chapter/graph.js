/**
 * моделирование сети при помощи новой структуры данных - графов
 * алгоритм - поиск в ширину (BFS - Breadth-First Search)
 * топологическая сортировка - алгоритм сортировки? раскрывающий связи между узлами
 * задачи: кратчайший путь ведет к Х? 
 * игра в шашки - вычисляет кратчайший путь к победе
 * реализовать проверку правописания (АЛГОРИФМ -> АЛГОРИТМ)
 * Граф - моделирует набор связей.
 * Каждый граф - состоит из узлов и ребер.
 * Графы - используются для моделирования связей между разными объектами.
 * Поиск в ширину - также относится к алгоритмам поиска, но графов
 * Поиск в ширину - помогает ответить на 2 типа вопросов:
 *  * тип 1: существует ли путь от узла А к узлу В?
 *  * тип 2: как выглядит кратчайший путь от узла А к узлу В?
 * очередь - quee - FIFO - First-In First-Out - постановка в очередь и извлечение из очереди
 * стек - LIFO - Last-In First-Out
 * направленный и ненаправленный графы
 *  * Направленный граф - имеет стрелки, а отношения действуют в направлении стрелки (Рама -> Адит означает "Рама должен Адиту")
 *  * Ненаправленный граф - нет стрелок, а отношение идет в обе стороны (Росс - Рейчел означает "Росс встречается с Рейчел, а Рейчел встречается с Россом")
 * Реализация алгоритма:
 *  1 - создать очередь с именами проверяемых людей
 *  2 - извлечь из очереди очередного человека
 *  3 - проверить, яв-ся ли этот человек продавцом манго
 *  4 - Да=>Завершить   Нет=>5
 *  5 - Цикл - повторить все начиная со 2 пункта
 *  6 - Если очередь пуста, в вашей сети нет продавцов манго
 * Топологическая сортировка - способ построения упорядоченного списка на основе графа. Задача А зависит от задачи В.
 * Дерево - разновидность графа не имеющая стреклок вверх.
 * *** Людей следует проверять в порядке их добавления в список поиска, поэтому список поиска должен быть очередь, иначе найденный путь не будет кратчайшим
 * *** Позаботьтесь о том, чтобы уже проверенный человек не проверялся заново, иначе может возникнуть бесконечный цикл
*/

//python
graph = {}
graph["you"] = ["alice", "bob", "claire"]

//все начинается с создания очеред. Двусторонняя очередь (deque)
// from collections import deque
// search_queue = deque() // <-------------------------создание новой очереди
// search_queue += graph["you"] // <-------------------все соседи добавляются в очередь поиска

// while search_queue // <-------------------------пока очередь не пуста
//     person = search_queue.popleft() // <--------из очереди извлекается первый человек
//     if person_is_seller(person): // <-----------провереям, яв-ся ли этот человек продавцом манго. внизу функция реализована
//         print person + " is a mango seller!" // <-----Да, это продавец манго
//         return true
//     else
//         search_queue += graph[person] // <-------Нет, не яв-ся. Все его друзья добавляются в очередь поиска
//         return false


// def person_is_seller(name):
//     return name[-1] == 'm'


//ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ КОДА
// def search(name):
//     search_queue = deque()
//     search_queue += graph(name)
//     searched = [] // <------------------------------------этот массив используется для отслеживания уже проверенных людей
//     while search_queue:
//         person = search_queue.popleft()
//         if not person in searched: // <-------------------человек проверяется только в том случае, если он не проверялся ранее
//             if person_is_seller(person):
//                 print person + " is a mango seller!"
//                 return true
//             else
//                 search_queue += graph[person]
//                 searched.append(person) // <--------------человек помечается как уже проверенный
//                 return false

// search("you")